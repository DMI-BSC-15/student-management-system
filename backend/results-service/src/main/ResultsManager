package com.example;


import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;

import jakarta.persistence.*;
import org.springframework.data.jpa.repository.JpaRepository;

import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;
import java.util.Scanner;

import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDPage;
import org.apache.pdfbox.pdmodel.common.PDRectangle;
import org.apache.pdfbox.pdmodel.font.PDType1Font;
import org.apache.pdfbox.pdmodel.font.Standard14Fonts;
import org.apache.pdfbox.pdmodel.PDPageContentStream;

/**
 * ResultsManagement (single-file Spring Boot app)
 *
 * Save as: src/main/java/com/example/results/ResultsManagement.java
 *
 * Notes:
 *  - Make sure application.properties is configured for your MySQL connection.
 *  - Build with Maven after replacing the file.
 */
@SpringBootApplication
public class ResultsManager {

    public static void main(String[] args) {
        SpringApplication.run(ResultsManager.class, args);
    }


    @Bean
    CommandLineRunner cliRunner(ResultsService resultsService, StudentRepository studentRepo, ModuleRepository moduleRepo, ResultRepository resultRepo) {
        return args -> {
            // run CLI only if --cli argument is present
            boolean cli = Arrays.stream(args).anyMatch(a -> a.equalsIgnoreCase("--cli"));
            if (!cli) return;

            Scanner scanner = new Scanner(System.in);
            System.out.println("=== Results Management CLI ===");

            outer: while (true) {
                System.out.println("\nChoose an option:");
                System.out.println("1) Add student");
                System.out.println("2) Add module");
                System.out.println("3) Enter / update result");
                System.out.println("4) Compute & show GPA for student (by term)");
                System.out.println("5) Generate transcript PDF for student (saved to working dir)");
                System.out.println("6) List students / modules / results");
                System.out.println("7) Exit CLI");
                System.out.print("Enter choice: ");
                String ch = scanner.nextLine().trim();
                try {
                    switch (ch) {
                        case "1" -> {
                            System.out.print("Student number: ");
                            String sn = scanner.nextLine().trim();
                            System.out.print("First name: ");
                            String fn = scanner.nextLine().trim();
                            System.out.print("Last name: ");
                            String ln = scanner.nextLine().trim();
                            Student s = resultsService.addStudent(sn, fn, ln);
                            System.out.println("Added student id=" + s.getId());
                        }
                        case "2" -> {
                            System.out.print("Module code: ");
                            String code = scanner.nextLine().trim();
                            System.out.print("Module name: ");
                            String name = scanner.nextLine().trim();
                            System.out.print("Credits: ");
                            int credits = Integer.parseInt(scanner.nextLine().trim());
                            Module m = resultsService.addModule(code, name, credits);
                            System.out.println("Added module id=" + m.getId());
                        }
                        case "3" -> {
                            System.out.println("Students:");
                            studentRepo.findAll().forEach(s -> System.out.printf("%d) %s - %s%n", s.getId(), s.getStudentNumber(), s.getFullName()));
                            System.out.print("Student id: "); int sid = Integer.parseInt(scanner.nextLine().trim());
                            System.out.println("Modules:");
                            moduleRepo.findAll().forEach(m -> System.out.printf("%d) %s - %s (%dcr)%n", m.getId(), m.getCode(), m.getName(), m.getCredits()));
                            System.out.print("Module id: "); int mid = Integer.parseInt(scanner.nextLine().trim());
                            System.out.print("Term: "); String term = scanner.nextLine().trim();
                            System.out.print("Mark: "); double mark = Double.parseDouble(scanner.nextLine().trim());
                            ResultEntity r = resultsService.enterOrUpdateResult(sid, mid, term, mark);
                            System.out.println("Saved result id=" + r.getId());
                        }
                        case "4" -> {
                            System.out.println("Students:");
                            studentRepo.findAll().forEach(s -> System.out.printf("%d) %s - %s%n", s.getId(), s.getStudentNumber(), s.getFullName()));
                            System.out.print("Student id: "); int sid = Integer.parseInt(scanner.nextLine().trim());
                            System.out.print("Term: "); String term = scanner.nextLine().trim();
                            OptionalDouble gpa = resultsService.computeGPA(sid, term);
                            if (gpa.isPresent()) System.out.printf("GPA for %s: %.3f%n", term, gpa.getAsDouble());
                            else System.out.println("No results for that term.");
                        }
                        case "5" -> {
                            System.out.println("Students:");
                            studentRepo.findAll().forEach(s -> System.out.printf("%d) %s - %s%n", s.getId(), s.getStudentNumber(), s.getFullName()));
                            System.out.print("Student id: "); int sid = Integer.parseInt(scanner.nextLine().trim());
                            System.out.print("Term (or ALL): "); String term = scanner.nextLine().trim();
                            byte[] pdf = resultsService.generateTranscriptPdf(sid, term.isBlank() ? "ALL" : term);
                            String filename = String.format("transcript_%d_%s.pdf", sid, (term.isBlank() ? "ALL" : term).replaceAll("\\s+","_"));
                            java.nio.file.Files.write(java.nio.file.Path.of(filename), pdf);
                            System.out.println("Transcript saved: " + filename);
                        }
                        case "6" -> {
                            System.out.println("Students:");
                            studentRepo.findAll().forEach(s -> System.out.printf("%d) %s - %s%n", s.getId(), s.getStudentNumber(), s.getFullName()));
                            System.out.println("\nModules:");
                            moduleRepo.findAll().forEach(m -> System.out.printf("%d) %s - %s (%dcr)%n", m.getId(), m.getCode(), m.getName(), m.getCredits()));
                            System.out.println("\nResults:");
                            resultRepo.findAll().forEach(rr -> System.out.printf("%d) student=%s module=%s term=%s mark=%.2f%n",
                                    rr.getId(), rr.getStudent().getStudentNumber(), rr.getModule().getCode(), rr.getTerm(), rr.getMark()));
                        }
                        case "7" -> { System.out.println("Exiting CLI..."); break outer; }
                        default -> System.out.println("Invalid choice");
                    }
                } catch (Exception ex) {
                    System.err.println("Error: " + ex.getMessage());
                }
            }

            System.out.println("CLI finished. Shutting down application.");
            // stop the Spring app so it does not keep the server running
            System.exit(0);
        };
    }



    // Optional: seed sample data when DB empty
    @Bean
    CommandLineRunner seedData(StudentRepository studentRepo, ModuleRepository moduleRepo, ResultRepository resultRepo) {
        return args -> {
            if (studentRepo.count() == 0 && moduleRepo.count() == 0) {
                Student s1 = new Student("S1001", "Alice", "Mwale");
                Student s2 = new Student("S1002", "Bob", "Phiri");
                studentRepo.saveAll(List.of(s1, s2));

                Module m1 = new Module("CS101", "Intro to Programming", 3);
                Module m2 = new Module("MT101", "Discrete Mathematics", 3);
                Module m3 = new Module("EN101", "English", 2);
                moduleRepo.saveAll(List.of(m1, m2, m3));

                resultRepo.saveAll(List.of(
                        new ResultEntity(s1, m1, "2024-T1", 78.0),
                        new ResultEntity(s1, m2, "2024-T1", 65.0),
                        new ResultEntity(s1, m3, "2024-T1", 55.0),
                        new ResultEntity(s2, m1, "2024-T1", 48.0),
                        new ResultEntity(s2, m2, "2024-T1", 39.0)
                ));
            }
        };
    }
}

/* ============================
   Entities (top-level, package-private)
   ============================ */

@Entity
@Table(name = "students")
class Student {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(name = "student_number", unique = true, nullable = false)
    private String studentNumber;

    @Column(name = "first_name", nullable = false)
    private String firstName;

    @Column(name = "last_name", nullable = false)
    private String lastName;

    public Student() {}
    public Student(String studentNumber, String firstName, String lastName) {
        this.studentNumber = studentNumber;
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public Integer getId() { return id; }
    public String getStudentNumber() { return studentNumber; }
    public void setStudentNumber(String studentNumber) { this.studentNumber = studentNumber; }
    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    public String getFullName() { return firstName + " " + lastName; }
}

@Entity
@Table(name = "modules")
class Module {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Column(name = "code", unique = true, nullable = false)
    private String code;

    @Column(name = "name", nullable = false)
    private String name;

    @Column(name = "credits", nullable = false)
    private Integer credits;

    public Module() {}
    public Module(String code, String name, Integer credits) { this.code = code; this.name = name; this.credits = credits; }

    public Integer getId() { return id; }
    public String getCode() { return code; }
    public void setCode(String code) { this.code = code; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public Integer getCredits() { return credits; }
    public void setCredits(Integer credits) { this.credits = credits; }
}

@Entity
@Table(name = "results",
        uniqueConstraints = @UniqueConstraint(columnNames = {"student_id", "module_id", "term"}))
class ResultEntity {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @ManyToOne(optional = false, fetch = FetchType.EAGER)
    @JoinColumn(name = "student_id")
    private Student student;

    @ManyToOne(optional = false, fetch = FetchType.EAGER)
    @JoinColumn(name = "module_id")
    private Module module;

    @Column(name = "term", nullable = false)
    private String term;

    @Column(name = "mark", nullable = false)
    private Double mark;

    public ResultEntity() {}
    public ResultEntity(Student student, Module module, String term, Double mark) {
        this.student = student; this.module = module; this.term = term; this.mark = mark;
    }

    public Integer getId() { return id; }
    public Student getStudent() { return student; }
    public Module getModule() { return module; }
    public String getTerm() { return term; }
    public Double getMark() { return mark; }
    public void setStudent(Student student) { this.student = student; }
    public void setModule(Module module) { this.module = module; }
    public void setTerm(String term) { this.term = term; }
    public void setMark(Double mark) { this.mark = mark; }
}

/* ============================
   Repositories (package-private top-level)
   ============================ */

interface StudentRepository extends JpaRepository<Student, Integer> {
    Optional<Student> findByStudentNumber(String studentNumber);
}

interface ModuleRepository extends JpaRepository<Module, Integer> {
    Optional<Module> findByCode(String code);
}

interface ResultRepository extends JpaRepository<ResultEntity, Integer> {
    // Spring Data derives queries by property path (student.id => findByStudentId...)
    List<ResultEntity> findByStudentIdAndTerm(Integer studentId, String term);
    List<ResultEntity> findByStudentId(Integer studentId);
    Optional<ResultEntity> findByStudentIdAndModuleIdAndTerm(Integer studentId, Integer moduleId, String term);
}

/* ============================
   Service
   ============================ */

@Service
@Transactional
class ResultsService {
    private final StudentRepository studentRepo;
    private final ModuleRepository moduleRepo;
    private final ResultRepository resultRepo;

    @Autowired
    public ResultsService(StudentRepository studentRepo, ModuleRepository moduleRepo, ResultRepository resultRepo) {
        this.studentRepo = studentRepo;
        this.moduleRepo = moduleRepo;
        this.resultRepo = resultRepo;
    }

    public Student addStudent(String studentNumber, String firstName, String lastName) {
        Student s = new Student(studentNumber, firstName, lastName);
        return studentRepo.save(s);
    }

    public Module addModule(String code, String name, int credits) {
        Module m = new Module(code, name, credits);
        return moduleRepo.save(m);
    }

    public ResultEntity enterOrUpdateResult(Integer studentId, Integer moduleId, String term, Double mark) {
        Optional<ResultEntity> existing = resultRepo.findByStudentIdAndModuleIdAndTerm(studentId, moduleId, term);
        if (existing.isPresent()) {
            ResultEntity r = existing.get();
            r.setMark(mark);
            return resultRepo.save(r);
        } else {
            Student s = studentRepo.findById(studentId).orElseThrow(() -> new NoSuchElementException("Student not found"));
            Module m = moduleRepo.findById(moduleId).orElseThrow(() -> new NoSuchElementException("Module not found"));
            ResultEntity r = new ResultEntity(s, m, term, mark);
            return resultRepo.save(r);
        }
    }

    // grade point mapping
    private double markToPoint(double mark) {
        if (mark >= 70) return 4.0;
        if (mark >= 60) return 3.0;
        if (mark >= 50) return 2.0;
        if (mark >= 40) return 1.0;
        return 0.0;
    }

    public OptionalDouble computeGPA(Integer studentId, String term) {
        List<ResultEntity> results = resultRepo.findByStudentIdAndTerm(studentId, term);
        if (results.isEmpty()) return OptionalDouble.empty();
        double totalPointsTimesCredits = 0.0;
        int totalCredits = 0;
        for (ResultEntity r : results) {
            double gp = markToPoint(r.getMark());
            int credits = r.getModule().getCredits();
            totalPointsTimesCredits += gp * credits;
            totalCredits += credits;
        }
        if (totalCredits == 0) return OptionalDouble.empty();
        return OptionalDouble.of(totalPointsTimesCredits / totalCredits);
    }

    public List<ResultEntity> getResultsForStudent(Integer studentId) {
        return resultRepo.findByStudentId(studentId);
    }

    public List<String> getTermsForStudent(Integer studentId) {
        return resultRepo.findByStudentId(studentId).stream()
                .map(ResultEntity::getTerm)
                .distinct()
                .sorted()
                .collect(Collectors.toList());
    }

    public byte[] generateTranscriptPdf(Integer studentId, String term) throws IOException {
        Student s = studentRepo.findById(studentId).orElseThrow(() -> new NoSuchElementException("Student not found"));
        List<ResultEntity> rows;
        if (term == null || term.isBlank() || "ALL".equalsIgnoreCase(term)) {
            rows = resultRepo.findByStudentId(studentId);
        } else {
            rows = resultRepo.findByStudentIdAndTerm(studentId, term);
        }
        if (rows.isEmpty()) throw new NoSuchElementException("No results for that query");

        Map<String, Double> termGpas = new LinkedHashMap<>();
        List<String> terms = rows.stream().map(ResultEntity::getTerm).distinct().sorted().collect(Collectors.toList());
        for (String t : terms) {
            OptionalDouble gpa = computeGPA(studentId, t);
            termGpas.put(t, gpa.isPresent() ? gpa.getAsDouble() : Double.NaN);
        }

        try (PDDocument doc = new PDDocument()) {
            PDPage page = new PDPage(PDRectangle.LETTER);
            doc.addPage(page);

            PDPageContentStream cs = new PDPageContentStream(doc, page);
            cs.beginText();
            cs.setFont(new PDType1Font(Standard14Fonts.FontName.TIMES_BOLD), 18);
            cs.newLineAtOffset(50, 720);
            cs.showText("Transcript");
            cs.endText();

            cs.beginText();
            cs.setFont(new PDType1Font(Standard14Fonts.FontName.TIMES_ROMAN), 12);
            cs.newLineAtOffset(50, 700);
            cs.showText("Student: " + s.getFullName() + "    Number: " + s.getStudentNumber());
            cs.endText();

            float y = 670;
            cs.setFont(new PDType1Font(Standard14Fonts.FontName.TIMES_BOLD), 12);
            cs.beginText();
            cs.newLineAtOffset(50, y);
            cs.showText(String.format("%-12s %-10s %-40s %6s %8s", "Term", "Code", "Module name", "Credits", "Mark"));
            cs.endText();
            y -= 18;

            cs.setFont(new PDType1Font(Standard14Fonts.FontName.TIMES_ROMAN), 11);
            for (ResultEntity r : rows) {
                if (y < 80) {
                    cs.close();
                    page = new PDPage(PDRectangle.LETTER);
                    doc.addPage(page);
                    cs = new PDPageContentStream(doc, page);
                    y = 720;
                }
                cs.beginText();
                cs.newLineAtOffset(50, y);
                String modName = r.getModule().getName();
                if (modName.length() > 35) modName = modName.substring(0, 32) + "...";
                String line = String.format("%-12s %-10s %-40s %6d %8.2f",
                        r.getTerm(), r.getModule().getCode(), modName, r.getModule().getCredits(), r.getMark());
                cs.showText(line);
                cs.endText();
                y -= 15;
            }

            y -= 10;
            cs.setFont(new PDType1Font(Standard14Fonts.FontName.TIMES_BOLD), 12);
            cs.beginText();
            cs.newLineAtOffset(50, y);
            cs.showText("Term GPAs:");
            cs.endText();
            y -= 16;
            cs.setFont(new PDType1Font(Standard14Fonts.FontName.TIMES_ROMAN), 11);
            for (Map.Entry<String, Double> e : termGpas.entrySet()) {
                cs.beginText();
                cs.newLineAtOffset(50, y);
                String gpaStr = Double.isNaN(e.getValue()) ? "N/A" : String.format("%.3f", e.getValue());
                cs.showText(String.format("%s : %s", e.getKey(), gpaStr));
                cs.endText();
                y -= 14;
            }

            cs.close();

            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            doc.save(baos);
            return baos.toByteArray();
        }
    }
}

/* ============================
   REST Controller
   ============================ */

@RestController
@RequestMapping("/api")
class ResultsController {

    private final ResultsService service;
    private final StudentRepository studentRepo;
    private final ModuleRepository moduleRepo;

    @Autowired
    public ResultsController(ResultsService service, StudentRepository studentRepo, ModuleRepository moduleRepo) {
        this.service = service;
        this.studentRepo = studentRepo;
        this.moduleRepo = moduleRepo;
    }

    // Students
    @PostMapping("/students")
    public Student addStudent(@RequestBody Map<String, String> body) {
        String sn = body.get("studentNumber");
        String fn = body.get("firstName");
        String ln = body.get("lastName");
        return service.addStudent(sn, fn, ln);
    }

    @GetMapping("/students")
    public List<Student> listStudents() { return studentRepo.findAll(); }

    @GetMapping("/students/{id}")
    public Student getStudent(@PathVariable Integer id) { return studentRepo.findById(id).orElseThrow(() -> new NoSuchElementException("Student not found")); }

    // Modules
    @PostMapping("/modules")
    public Module addModule(@RequestBody Map<String, Object> body) {
        String code = (String) body.get("code");
        String name = (String) body.get("name");
        Integer credits = (Integer) (body.get("credits") instanceof Integer ? body.get("credits") : Integer.valueOf(body.get("credits").toString()));
        return service.addModule(code, name, credits);
    }

    @GetMapping("/modules")
    public List<Module> listModules() { return moduleRepo.findAll(); }

    // Results
    @PostMapping("/results")
    public ResultEntity addOrUpdateResult(@RequestBody Map<String, Object> body) {
        Integer studentId = (Integer) (body.get("studentId") instanceof Integer ? body.get("studentId") : Integer.valueOf(body.get("studentId").toString()));
        Integer moduleId = (Integer) (body.get("moduleId") instanceof Integer ? body.get("moduleId") : Integer.valueOf(body.get("moduleId").toString()));
        String term = (String) body.get("term");
        Double mark = Double.valueOf(body.get("mark").toString());
        return service.enterOrUpdateResult(studentId, moduleId, term, mark);
    }

    @GetMapping("/students/{id}/results")
    public List<Map<String,Object>> getStudentResults(@PathVariable Integer id) {
        List<ResultEntity> results = service.getResultsForStudent(id);
        return results.stream().map(r -> {
            Map<String,Object> m = new LinkedHashMap<>();
            m.put("id", r.getId());
            m.put("studentId", r.getStudent().getId());
            m.put("studentNumber", r.getStudent().getStudentNumber());
            m.put("moduleId", r.getModule().getId());
            m.put("moduleCode", r.getModule().getCode());
            m.put("moduleName", r.getModule().getName());
            m.put("credits", r.getModule().getCredits());
            m.put("term", r.getTerm());
            m.put("mark", r.getMark());
            return m;
        }).collect(Collectors.toList());
    }

    @GetMapping("/students/{id}/gpa")
    public Map<String,Object> getGpa(@PathVariable Integer id, @RequestParam String term) {
        OptionalDouble gpa = service.computeGPA(id, term);
        Map<String,Object> m = new HashMap<>();
        m.put("studentId", id);
        m.put("term", term);
        m.put("gpa", gpa.isPresent() ? gpa.getAsDouble() : null);
        return m;
    }

    @GetMapping("/students/{id}/terms")
    public List<String> getTerms(@PathVariable Integer id) { return service.getTermsForStudent(id); }

    @GetMapping("/students/{id}/transcript")
    public ResponseEntity<byte[]> transcriptPdf(@PathVariable Integer id, @RequestParam(defaultValue = "ALL") String term) {
        try {
            byte[] pdf = service.generateTranscriptPdf(id, term);
            String filename = String.format("transcript_%d_%s.pdf", id, term.replaceAll("\\s+","_"));
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + filename + "\"")
                    .contentType(MediaType.APPLICATION_PDF)
                    .body(pdf);
        } catch (NoSuchElementException e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
        } catch (IOException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }
}
